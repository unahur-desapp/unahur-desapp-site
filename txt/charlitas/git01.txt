Git - voy tirando elementos

1. 
Contexto - un poco de git

Qué problema ataca Git: muchas manos en un plato hacen mucho garabato.
Este problema es viejo como el gremio, históricamente fuente de muchos errores y retrasos.
- piensen en un equipo de ... 8 personas, que no es tanto.
- podemos laburar cada uno por su lado, pero: la integración después duele, y se potencia el riesgo de hacer varias veces lo mismo.
  Pregunta: ¿cuándo integramos?
  - al final después de 9 meses: desastre garantizado
  - todos los días: costo de integración todo el tiempo, nos terminamos mareando.

Hubo muchas propuestas y herramientas. La verdad, Git es la primera satisfactoria de uso masivo (hubo otras copadas pero de nicho, p.ej. Envy).

Por eso la industria se volcó rápida y masivamente a Git, y hoy medio que no nos acordamos de cómo era la vida antes de Git.
No necesariamente es perfecto, en mi opinión personal está un poco sobredimensionado para proyectos chicos ... reflexión sobre la existencia de herramientas de soporte que sean copadas para toda escala de proyectos.

Git es un mundo, tiene un montón de características, está concebido para los proyectos más complejos, que son los masivos de open source.
De hecho, lo inventó Torvalds para Linux.
Probar en línea de comandos con
- git
- git help -a

Acá vamos a ver un cachito así. En el material que subí al sitio se habla bastante más en profundidad de lo que vamos a hablar acá.
Como recomendación de la casa, también tienen los tutoriales de Atlassian.
Y también como recomendación, es mucho muy apreciado tenerla lisa con Git, da laburo.

(parar un segundo a ver si logran apreciar el valor de lo que están recibiendo)


2.
A qué le vamos a apuntar.

De qué se trata Git ya lo saben porque lo usaron (creo) en al menos 4 materias.
El foco acá es cómo manejar Git, y cómo nos puede ayudar Git, en un proyecto en donde somos cuatro/cinco codeando.

Siendo que son pocos se podríiiiia (tal vez, la verdad ni sé si convendría) pensar en otro esquema. Pero ... el manejo de Git en el contexto de un proyecto largo (de 9 meses, un parto) es una de las cosas que se llevan de la/s materia/s ... y que se evalúa.

Entonces, primero vamos a ver el esquema, y después vamos a hablar un poco de características de Git.


3.
El esquema: feature branch.

Mostrar el dibujo. Así es como queremos que trabajen.

Podemos tomar "feature" como "tarea" o "tarjeta de Trello". De hecho, asociar un branch a una tarjeta/tarea del manejador de proyectos es una práctica habitual.

Qué nos permite esto: cada uno labura por separado, y después se integra sobre la rama develop (o dev). Master no lo tocamos nunca de los jamases x ahora.

Consecuencia: cada uno no ve los cambios que hacen los otros hasta que integra. 
Ventaja: no nos pisamos.
Desventaja: si necesito algo que está haciendo el otro, no lo tengo.


4.
Un mínimo de conceptos Git.

¿Saben lo que es un branch?
Hacer un ejemplo en vivo sobre simple-linear-history, ver d:\temp\git-clase.
Tenemos tres archivos: fruta, carne, verdura. Y tres usuaries: clombardi / laura-git / roque-git.
Cada persona va a hacer una tarea
- clombardi     agregar fruta 
- laura-git     agregar verdura
- roque-git     meter pescado

cómo quedaría el dibujito después de que cada une mete un commit de acuerdo a lo que vimos.
- esto hacerlo sobre el editor Web de gráfico.

Mostrar en vivo cómo saltando de branch cambia lo que veo. No, no se pierde. Y si meto todo en el remoto, está en el server además de en mi compu.
¿Y "dónde está" el código de los branches? En algún lado, si quieren saber, en la carpeta .git, en un formato que ... pregúntenle a Torvalds.

Script
s1. cada uno crea un branch (repasemos cómo es), y mete un commit + push. Esto indicar sobre el editor gráfico que pasa en cada pasito.
s2. me paro en clombardi, mando un pull, qué pasó. Se puede hacer el git log --oneline --graph --all, comparar con el dibujo.  
    También se puede ver en la UI Web de GitLab.
s3. siempre en clombardi, me voy parando en los distintos branches. 


5.
Procedimiento de trabajo (esto lo puedo ir haciendo)

5.1. cuando empiezo una tarea
- git checkout dev
- git pull
- git checkout -b <branch-de-mi-tarea>

5.2. trabajo diario
Cuando arranco: 
- git checkout dev
- git pull
- git checkout <mi-tarea>

laburo, git commit. Antes de salir de la compu, git push. No jodo a nadie porque pusheo en mi branch, y si rompo mi copia local, siempre está el respaldo en el repo remoto.

Script (agarrate que es largo)
s1. se simula una sesión de trabajo de Laura en la que mete un commit.
s2. se simula una sesión de trabajo de clombardi en la que mete dos commits.


5.3. Cuando termino una tarea

Puede ser que alguien haya hecho algo algo, o no.

Dentro de las distintas formas de sincronizarse, la que se va a recomendar acá es usar rebase. 
Explicar "en dibujitos" qué onda.

(
  arrancar de acá el martes 11/05
  el dibujito para cargar en el graficador online está en
  D:\carlos\educ\desapp\site\images\intermediate-work-in-three-branches-simulation.drawio
)

Hands-on
s1. sesión de trabajo de roque, mete un commit. 
s2. resulta que roque terminó.
    Mirar bien el estado del repo, y qué queremos: que dev apunte al resultado del trabajo de roque.
    Lo hacemos.
s3. Ver qué ve cada une en este momento.
s4. sesión de trabajo de clombardi. Qué pasa en el pull.
    Mete un commit.
    Terminó. Mirar bien el estado del repo, y qué queremos: que dev integre la contribución de Roque y la de clombardi.
    Acá se ve bien el efecto del rebase.
s5. sesión de trabajo de laura.
s6. sesión de trabajo de roque: tarea que agrega más fruta, empieza y termina incluyendo el push.
    Momento, roque quiere empezar una tarea. ¿de dónde sale el branch?
    Acá repasamos cómo es crear una tarea, y por qué hace falta git checkout dev + git pull.
s7. laura decide que terminó ... pero mientras tanto entró la tarea de roque. 
    Acá ver la relevancia del git checkout dev + git pull antes de rebase.


5.4. La receta

- git checkout dev
- git pull
- git checkout <mi-tarea>
- git rebase dev
- git push -f

Acá "subí" mi branch arriba de dev (repasar los dibujitos despacito).
Pruebo, y después

- git checkout dev
- git merge <mi-tarea>
- git push.

Lo que sí se tienen que sincronizar, es no hacer la integración a dev varies al mismo tiempo. Obvio que para equipos grandes eso no escala ... pero con que manejen git "hasta acá" estamos más que bien.



6.
Otras pautas

¿Puede haber conflictos? Sí. 
Lo que vamos a hacer, al menos por (un largo) ahora, es evitarlos, trabajando sobre files separados, y eventualmente (y poquito), sobre secciones separadas del mismo archivo.

Incluso podemos p.ej. crear varias rutas con componentes que vayan a un <div></div> y después cada uno desarrolla. Así no tocamos todes el archivo de rutas.
Si tocamos un mismo archivo, definimos secciones separadas, por líneas con comentarios. O mejor, definimos distintas funciones.
Y sí, hay que planificar un toque.

Probar con dos tareas que tocan el mismo archivo, uno al ppio el otro al final. Sirve para repasar las recetas.

Si vamos a hacer algo entre varies, o lo que hacemos tiene algo en común.
- primero armamos una estructura. Esto conviene hacerlo estando conectades.
- si podemos, esto solito lo mandamos a dev. Después cada une hace su parte en branch separado, como vimos. Esto aplica p.ej. a lo que hablamos recién de las rutas.
- si nos interesa separar esta tarea como una unidad, sacamos los branches para cada une desde el nuevo branch, después integramos a ese branch, y cuando estamos todes contentes, ese branch de "integración parcial" va a dev.
  Podemos hacer un poco de dibujitos.

Si estoy haciendo dos cosas que no tienen nada que ver, pues armo dos branches. Como ya vimos, puedo saltar libremente de uno al otro y no pierdo nada.
Pero **ojo** antes de saltar tengo que commitear.
(para entender un poco más ... mostrar el dibujo de "los lugares")

Si voy a hacer una tarea larga que tarde mucho, corro el riesgo de que dev esté muy distinto cuando me toque integrar. Cómo lo mitigo: rebase dev cada tanto (*sin* olvidar hacer pull de dev antes de rebasear).


7.
Local y remoto


8.
Pull requests = merge requests
